// This file was GENERATED by command:
//     pump.py to_xml.hpp.pump
// DO NOT EDIT BY HAND!!!

#ifndef TO_XML_HPP
#define TO_XML_HPP
#include <string>
#include <vector>
#include <map>

inline
void xml_escape(std::string &sString) {
        int length = sString.length();
        char buf[length * 10 + 128];
        memset(buf, 0, sizeof(buf));

        char* it = (char*) sString.c_str();
        char *out = buf;
	int ch = 0;
	for (int i = 0; i < length; ++i){
		ch = (unsigned char)(*it);
                switch (ch) {

#define XML_ESCAPE(ch, rep)  \
		case ch: \
			memcpy(out, rep, sizeof(rep)-1); \
			out += (sizeof(rep)-1); \
                        break;\
	
		XML_ESCAPE('<', "&lt;");	
		XML_ESCAPE('>', "&gt;");	
		XML_ESCAPE('&', "&amp;");	
		XML_ESCAPE('\'', "&apos;");	
		XML_ESCAPE('\"', "&quot;");	

                default:
			if (!( (0 <= ch) && (ch <= 31) &&
				(ch != 9) && (ch != 10) && (ch != 13)) )
			{
				*out = ch;
				++out;
                        }
                }
		++it;
        }
        sString = buf;
        return;
}

#define DEF_BASETYPE_TO_XML_VALUE(fmt, type) \
inline \
void to_xml(std::string &out, type value) { \
    char buffer[sizeof(typeof(value))*3+4]; \
    snprintf(buffer, sizeof(buffer), fmt, value); \
    out.append(buffer); \
} \


DEF_BASETYPE_TO_XML_VALUE("%d", int)
DEF_BASETYPE_TO_XML_VALUE("%u", unsigned int)
DEF_BASETYPE_TO_XML_VALUE("%ld", long)
DEF_BASETYPE_TO_XML_VALUE("%lu", unsigned long)
DEF_BASETYPE_TO_XML_VALUE("%lld", long long)
DEF_BASETYPE_TO_XML_VALUE("%llu", unsigned long long)
DEF_BASETYPE_TO_XML_VALUE("%f", double)
DEF_BASETYPE_TO_XML_VALUE("%Lf", long double)


inline
void to_xml(std::string &out, std::string str) {
	xml_escape(str);
	out.append(str);
}

inline
void to_xml(std::string &out, char const * str) {
	to_xml(out, std::string(str));
}


#define DEF_BASETYPE_TO_XML_MEMBER(t) \
inline \
void to_xml_member2(std::string & out, char const * name, std::vector<t> const & vec) { \
    std::string head_tag = "<"; \
    head_tag += name; head_tag += ">"; \
    std::string tail_tag = "</"; \
    tail_tag += name; tail_tag += ">"; \
	for ( size_t i=0, len=vec.size(); \
            i<len; ++i){ \
            out.append(head_tag); \
	        to_xml(out, vec[i]); \
            out.append(tail_tag); \
	} \
} \
inline  \
void to_xml_member2(std::string & out, char const *name, t const &value)  \
    {  \
        out.append("<");  \
        out.append(name);  \
        out.append(">");  \
        to_xml(out, value);  \
        out.append("</");  \
        out.append(name);  \
        out.append(">"); \
    }  \


DEF_BASETYPE_TO_XML_MEMBER(int)
DEF_BASETYPE_TO_XML_MEMBER(unsigned int)
DEF_BASETYPE_TO_XML_MEMBER(long)
DEF_BASETYPE_TO_XML_MEMBER(unsigned long)
DEF_BASETYPE_TO_XML_MEMBER(long long)
DEF_BASETYPE_TO_XML_MEMBER(unsigned long long)
DEF_BASETYPE_TO_XML_MEMBER(double)
DEF_BASETYPE_TO_XML_MEMBER(long double)
DEF_BASETYPE_TO_XML_MEMBER(char const*)
DEF_BASETYPE_TO_XML_MEMBER(std::string)

template <typename t>
inline
void to_xml_member(std::string & out, char const *name, std::vector<t> const & vec) {
	for ( size_t i=0, len=vec.size();
            i<len; ++i){
	       to_xml(out, vec[i]);
	}
}

#define to_xml_member(out, name) \
    do { \
        to_xml_member2(out, #name, name); \
    } while(0 )\


template<typename t>
inline 
void to_xml_member2(std::string & out, char const *name, t const &value) 
    { 
        to_xml(out, value, name); 
    } 


template <typename t>
inline
void to_xml(std::string & out, std::map<std::string, t> const & map) {
    size_t i=0;
    for (typeof(map.begin()) it = map.begin(), iend = map.end();
        it!=iend; ++it, ++i) {
       to_xml_member2(out, it->first.c_str(),  it->second);
    }
}

template <typename t>
inline
void to_xml(std::string & out, t const &v)  {
    v.to_xml(out);
}

template <typename t>
inline
void to_xml(std::string & out, t const &v, char const *name) {
    v.to_xml(out, name);
}

template <typename t>
inline
std::string to_xml(t const & v) {
    std::string out;
    to_xml(out, v);
    return out;
}

template <typename t>
inline
void to_xml_helper(std::string & out, t const &v, char const *name) {
    to_xml(out, v, name);
}

template <typename t>
inline
std::string to_xml_helper(t const & v) {
    return to_xml(v);
}

#define CAT(a, b) PRIMITIVE_CAT(a, b)
#define PRIMITIVE_CAT(a, b) a ## b
// binary intermediate split
#define SPLIT(i, im) PRIMITIVE_CAT(SPLIT_, i)(im)
#define SPLIT_0(a, b) a
#define SPLIT_1(a, b) b

// bit complement
#define COMPL(bit) PRIMITIVE_CAT(COMPL_, bit)
#define COMPL_0 1
#define COMPL_1 0
// nullary parentheses detection
#define IS_NULLARY(x) SPLIT(0, CAT(IS_NULLARY_R_, IS_NULLARY_C x))
#define IS_NULLARY_C() 1
#define IS_NULLARY_R_1 1, ~
#define IS_NULLARY_R_IS_NULLARY_C 0, ~

// boolean conversion
#define BOOL(x) COMPL(IS_NULLARY(PRIMITIVE_CAT(BOOL_, x)))
#define BOOL_0 ()

// bit-oriented if control structure
#define IIF(bit) PRIMITIVE_CAT(IIF_, bit)
#define IIF_0(t, f) f
#define IIF_1(t, f) t
// number-oriented if control structure
#define IF(cond) IIF(BOOL(cond))
#define EMPTY()
// 1x and 2x deferral macros
#define DEFER(macro) macro EMPTY()
#define OBSTRUCT() DEFER(EMPTY)()

$var max_element=30
$range i 1..max_element
$for i [[ 
#define XML_ATTR$(i)(...) ($(i), ##__VA_ARGS__)
]]

#define UNPACK1(...) __VA_ARGS__
#define UNPACK(a) CAT(UNPACK1,a)

#define UNPACK_HEAD1(a, ...) a
#define UNPACK_HEAD(a) UNPACK_HEAD1 a

#define UNPACK_REST1(a, ...) __VA_ARGS__
#define UNPACK_REST(a) UNPACK_REST1 a

#define PACK_ARGS(...) (__VA_ARGS__)

#define MACRO_CALL(macro, ...) macro(__VA_ARGS__)

#define IS_SIMPLE_PARAM(x) SPLIT(0, CAT(IS_SIMPLE_PARAM_R_, IS_SIMPLE_PARAM_C_ x))
#define IS_SIMPLE_PARAM_C_(...) 0
#define IS_SIMPLE_PARAM_R_0 0, ~
#define IS_SIMPLE_PARAM_R_IS_SIMPLE_PARAM_C_ 1, ~


$range i 1..max_element
$for i [[
$range j 1..i
#define XML_ATTR_OUT_$(i)($for j [[ $if j>1 [[,]] attr$(j)]]) \

$range j 1..i
$for j [[
	$if j>1 [[ 
		out.append(", " #attr$(j) "=\"");\
	]] $else [[
		out.append(" " #attr$(j) "=\"");\
	]]
	to_xml(out, v.attr$(j)); \ 
	out.append("\"");\
]]




]]

#define XML_FIRST_ATTR_OUT(tag_name, a)  \
	out.append("<"); out.append(tag_name); \
	MACRO_CALL(CAT(XML_ATTR_OUT_, UNPACK_HEAD(a)), UNPACK_REST(a)) \
	out.append(">"); \


#define XML_FIRST_ELEMENT_OUT(tag_name, a) \
	out.append("<"); out.append(tag_name), out.append(">");\
	to_xml_member2(out, #a, v.a);\



#define XML_PROCESS_FIRST_PARAM(tag_name, a) \
    IF(IS_SIMPLE_PARAM(a))(DEFER(XML_FIRST_ELEMENT_OUT) (tag_name, a), DEFER(XML_FIRST_ATTR_OUT)(tag_name, a))



$range i 1..max_element
$for i [[
$range j 1..i
#define DEF_TO_XML$(i)(type $for j [[, arg$(j)]]) \ 
inline \ 
void to_xml(std::string & out, type const & v, const char * tag_name=#type) { \ 
    XML_PROCESS_FIRST_PARAM(tag_name, arg1) \ 

$if i > 1 [[
$range j 2..i
$for j [[
    to_xml_member2(out, #arg$(j), v.arg$(j)); \  

]]
]]
    out.append("</"); out.append(tag_name); out.append(">"); \  
} \ 
inline \
std::string to_xml(type const & v) { \
    std::string out; \
    to_xml(out, v); \
    return out; \
}  \



]]



$range i 1..max_element
$for i [[
$range j 1..i
#define DEF_TO_XML_MEM$(i)(tagname $for j [[, arg$(j)]]) \ 
inline \ 
void to_xml(std::string & out, const char * tag_name=tagname) const { \ 
    typeof(*this) const &v = *this; \
    XML_PROCESS_FIRST_PARAM(tag_name, arg1) \ 

$if i > 1 [[
$range j 2..i
$for j [[
    to_xml_member2(out, #arg$(j), v.arg$(j)); \  

]]
]]
    out.append("</"); out.append(tag_name); out.append(">"); \  
} \ 
inline \
std::string to_xml() const{ \
	std::string out; \
	this->to_xml(out); \
	return out; \
}\



]]
#endif  //TO_XML_HPP
